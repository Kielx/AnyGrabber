import customtkinter
import tkinter
import os
import threading
import time
from collections import deque

from utils.file_operations import get_anydesk_logs

# Define paths to AnyDesk log files (ad.trace and ad_svc.trace)
app_data_path = os.getenv('APPDATA')
app_data_filename = f'{app_data_path}/AnyDesk/ad.trace'
program_data_path = os.getenv('PROGRAMDATA')
program_data_filename = f'{program_data_path}/AnyDesk/ad_svc.trace'

# Means of communication, between the gui & update threads:
message_queue = deque()
search_finished = False


def find_files(filename: str | list, search_path):
    """A function that searches for files in a given path and returns a list of paths to found files"""
    global search_finished
    search_finished = False
    # Walking top-down from the root
    for root, dir, files in os.walk(search_path):
        if type(filename) == list:
            for name in filename:
                if name in files:
                    message_queue.append(os.path.join(root, name))
        else:
            if filename in files:
                message_queue.append(os.path.join(root, filename))
    search_finished = True


class AnydeskFrame(customtkinter.CTkFrame):
    """A frame that contains widgets for fetching AnyDesk logs and displaying them in a textbox.
    """

    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # create checkbox and switch frame
        self.fetch_appdata_logs_switch = tkinter.BooleanVar()
        self.fetch_programdata_logs_switch = tkinter.BooleanVar()

        self.checkbox_slider_frame = customtkinter.CTkFrame(master=self)
        self.checkbox_slider_frame.grid(row=0, column=0, padx=(20, 20), pady=(20, 0), sticky="nsew")
        self.fetch_appdata_logs_checkbox = customtkinter.CTkCheckBox(master=self.checkbox_slider_frame,
                                                                     variable=self.fetch_appdata_logs_switch,
                                                                     onvalue=True, offvalue=False)
        self.fetch_appdata_logs_checkbox.grid(row=1, column=0, pady=(20, 0), padx=20, sticky="n")
        self.fetch_programdata_logs_checkbox = customtkinter.CTkCheckBox(master=self.checkbox_slider_frame,
                                                                         variable=self.fetch_programdata_logs_switch,
                                                                         onvalue=True, offvalue=False)
        self.fetch_programdata_logs_checkbox.grid(row=2, column=0, pady=(20, 0), padx=20, sticky="n")
        self.checkbox_3 = customtkinter.CTkCheckBox(master=self.checkbox_slider_frame)
        self.checkbox_3.grid(row=3, column=0, pady=20, padx=20, sticky="n")

        self.textbox = customtkinter.CTkTextbox(self)
        self.textbox.grid(row=2, column=0, padx=20, pady=20, sticky='nsew')

        self.fetch_logs_button = customtkinter.CTkButton(self,
                                                         command=self.button_callback,
                                                         text="Fetch logs")

        self.fetch_logs_button.grid(row=1, column=0, columnspan=2, padx=20, pady=(20, 0), sticky="ew")

    def button_callback(self):
        """A callback function that calls functions that print output generated by log fetching functions to textbox
        when appropriate switch is selected

        Clears texbox contents after it gets invoked, and disables textbox editing after fetching data"""
        self.textbox.configure(state="normal")
        self.textbox.delete("0.0", "end")  # delete all text
        if self.fetch_appdata_logs_switch.get():
            self.print_logs(log_filename_with_path=app_data_filename)
        if self.fetch_programdata_logs_switch.get():
            self.print_logs(log_filename_with_path=program_data_filename)
        if self.checkbox_3.get():
            self.fetch_logs_button.configure(state="disabled")
            threading.Thread(target=self.checkbox_callback, daemon=True).start()

    def print_logs(self, log_filename_with_path: str):
        print(f"Printing logs from {log_filename_with_path}")
        """A function that calls get_anydesk_logs function and prints output to textbox

        Shows a message if no logs are found in a file or if file doesn't exist

        :param log_filename_with_path: a path to a file that contains Anydesk logs
        """
        log_entries = get_anydesk_logs(log_filename_with_path)
        print(log_entries)
        if log_entries is not None:
            print(self)
            print(self.textbox)
            self.textbox.insert("insert", f'Fetching logs from {log_filename_with_path}: \n')
            print(self.textbox)
            if len(log_entries) < 1:
                self.textbox.insert("insert", "No IP logs found inside file!")
            else:
                for entry in log_entries:
                    self.textbox.insert("insert", entry + "\n\n")
        else:
            self.textbox.insert("insert", f'Logs not found in {log_filename_with_path} \n')

    def checkbox_callback(self):
        global search_finished
        self.textbox.insert("insert", "---- Searching for files, it may take a while! ----\n")
        progressbar = customtkinter.CTkProgressBar(master=self, mode="indeterminate")
        progressbar.grid(row=3, column=0, pady=20, padx=20, sticky="n")
        progressbar.start()
        search_finished = False
        self.update()
        find_files(["ad.trace", "ad_svc.trace"], "C:\\")
        progressbar.stop()
        progressbar.destroy()
        self.fetch_logs_button.configure(state="normal")

    def update(self):
        """A function that updates the frame's contents"""
        try:
            self.print_logs(message_queue.popleft())
        except IndexError:
            pass
        if not search_finished:
            self.after(2000, func=self.update)
        print("Updating frame...")
